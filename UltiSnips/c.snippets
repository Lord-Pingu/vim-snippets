global !p

# displays input list in text editor and returns match
def autocomplete(t, opts):
	if t:
		opts = [m[len(t):] for m in opts if m.startswith(t)]
	if len(opts) == 1:
		return opts[0]
	return "(" + "|".join(opts) + ")" 

# returns a matching bracket or quote
def matching_bracket(r):
	pairs = {"(": ")", "<": ">", "[": "]", "{": "}", "'": "'", '"': '"'}
	return pairs[r]

endglobal

snippet # "preprocessors" bA
#$1`!p
preprocessors = ["define", "include", "undef", "ifdef", "ifndef", "if", "else", "elif", "endif", "error", "pragma"]
snip.rv = autocomplete(t[1], preprocessors)` $0
endsnippet

snippet '\s(\(|\[|\{|"|\'|<)' "brackets and quotes" rw
 `!p snip.rv = match.group(1)`$1`!p snip.rv = matching_bracket(match.group(1))`$0
endsnippet

snippet '(\w+(\s|\*)+\w+)\s*\((.*)\)' "function def" rbA
`!p snip.rv = match.group(1) + f" ({match.group(3)})" if match.group(3) else f"{match.group(1)} (void)"`
{
	$1
}
$0
endsnippet

snippet het "heterogeneous data types" 
$1`!p snip.rv = autocomplete(t[1], ["enum", "union", "struct"])` $2${2/.+/ /}{
	$4
}${3/.+/ /}$3;$0
endsnippet

snippet do "do {} while ();" A
do {
	$2
} while ($1);$0
endsnippet

snippet while "while () {}" A
while ($1) {
	$2
}$0
endsnippet

snippet switch "switch statement" A
switch ($1)
{
	${2:*cases*}
}
endsnippet

snippet case "case" A
case $1:
	$2
$0
endsnippet

snippet for "for () {}"
for (int ${1:i} = ${2:0}; $1 ${3:<} $4; $1${5:--/++}) {
	$6
}$0
endsnippet

snippet printf "printf();" A
printf("$1${2:\n}"${3/.+/, /}$3);$0
endsnippet

snippet malloc "(<type cast>) malloc();" A
${1/.+/\(/}$1${1/.+/\) /}malloc($2);$0
endsnippet

snippet 'sizeof' "sizeof()" rA
sizeof($1)$0
endsnippet

snippet return "return ;" A
return $1;$0
endsnippet

snippet if "if () {}" 
if ($1) {
	$2
} $0
endsnippet

snippet '} elif' "elif () {}"
} elif ($1) {
	$2
} $0
endsnippet

snippet '} else' "else {}"
} else {
	$1
}$0
endsnippet
